
function makeTpl(str) {
  // Find the first whitespace char
  var idx1 = str.indexOf(' ');
  var idx2 = str.indexOf('>');
  var idx = Math.min(idx1, idx2);
  var pre = str.substr(0, idx);
  var post = str.substring(idx);

  return function(withAttr, i) {
    var attrStr = ' ' + withAttr + '=' + i + ' ';
    return pre + attrStr + post;
  };
}


// Plugin defaults â€“ added as a property on our plugin function.
$.fn.superviews.defaults = {
  prefix: 'ui',
  genAttrName: function(name) {
    return $.fn.superviews.defaults.prefix + '-' + name;
  },
  attributes: {
    for: function(value) {
      var $this = $(this);
      var dataKey = $.fn.superviews.defaults.prefix + '-for-data';
      var templateKey = $.fn.superviews.defaults.prefix + '-for-template';

      // If the array hasn't changed 'shape', do no work
      var data = $this.data(dataKey);
      if (data) {
        if (data.length === value.length) {
          // todo: and they contain the same items etc...
          $this.superviews();
          return;
        }
      }

      var template = $this.data(templateKey);
      if (!template) {
        template = $this.html().trim();
        $this.data(templateKey, template);
      }

      var withAttr = $.fn.superviews.defaults.genAttrName('with');

      function spliceSlice(str, index, count, add) {
        return str.slice(0, index) + (add || '') + str.slice(index + count);
      }
      $this.html('');
      var html = ''; //[];
      for (var i = 0; i < value.length; i++) {
        //html += spliceSlice(template, 4, 0, ' ' + withAttr + '="[' + i + ']"');
        //html.push($(template).attr(withAttr, '[' + i + ']'));
        $this.append($(template).attr(withAttr, '[' + i + ']'));
      }

      // //$this.html('');
      // var html = '';//[];
      // for (var i = 0; i < value.length; i++) {
      //   html += spliceSlice(template, 4, 0, ' ' + withAttr + '="[' + i + ']"');
      //   //html.push($(template).attr(withAttr, '[' + i + ']'));
      // }
      // $this.html(html);

      // make a copy of the current items
      $this.data(dataKey, value.slice());

      $this.superviews();
    },
    'with': function() {

    },
    click: 1,
    text: function(value) {
      $(this).text(value);
    },
    attr: function(value) {
      $(this).attr(value);
    },
    // value: function(value) {
    //   $(this).val(value);
    // },
    // hide: function(value) {
    //   $(this)[value ? 'hide' : 'show']();
    // },
    // title: function(value) {
    //   this.title = value;
    // },
    // max: function(value) {
    //   $(this).attr('max', value);
    // },
    // 'class': function(value) {
    //   var keys = Object.keys(value),
    //     key, val;

    //   for (var i = 0; i < keys.length; i++) {
    //     key = keys[i];
    //     val = value[key];
    //     $(this)[val ? 'addClass' : 'removeClass'](key);
    //   }
    // }
  },
  events: ['onclick', 'ondblclick', 'onmousedown', 'onmouseup', 'onmouseover', 'onmousemove', 'onmouseout',
    'ondragstart', 'ondrag', 'ondragenter', 'ondragleave', 'ondragover', 'ondrop', 'ondragend', 'onkeydown',
    'onkeypress', 'onkeyup', 'onload', 'onunload', 'onabort', 'onerror', 'onresize', 'onscroll', 'select', 'onchange',
    'onsubmit', 'onreset', 'onfocus', 'onblur'
  ]
};






<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Superviews</title>
    <script src="../index.js"></script>
</head>
<body>
    <div>
        <div>
            <input type="text" ui-bind="name">
            <input type="text" ui-bind="age">

            <address ui-with="address">
                <input type="text" ui-bind="line1">
                <input type="text" ui-bind="line2">
                <input type="text" ui-bind="line3">
                <input type="text" ui-bind="postcode">
                <span ui-text="Object.keys(address).length"></span>
            </address>

            <ul>
                <li ui-for="orders">
                    <span ui-text="product"></span>
                    <span ui-text="quantity"></span>
                    <span ui-text="Object.keys(address).length"></span>
                    <span ui-text="name"></span>
                    <span ui-text="age"></span>
                    <span ui-text="orders.length"></span>
                </li>
            </ul>
        </div>
    </div>
    <script>

        var app = {
            name: 'Fred Bloggs',
            age: 21,
            address: {
                line1: 'Line1',
                line2: 'Line2',
                line3: 'Line3',
                postcode: 'CW8'
            },
            orders: [
                { product: 'Eggs', quantity: 1 },
                { product: 'Milk', quantity: 2 },
                { product: 'Bread', quantity: 1 },
                { product: 'Bacon', quantity: 5 }
            ]

        };

        superviews(document.body, app);

    </script>
</body>
</html>










module = {};

/**
 * Default Options
 */
var defaultOptions = {
  prefix: 'ui',
  dupeAttrName: 'dupe',
  withAttrName: 'with',
  forAttrName: 'for',
  ifAttrName: 'if',
  attrsAttrName: 'attrs',
  textAttrName: 'text',
  htmlAttrName: 'html',
  valueAttrName: 'value',
  bindAttrName: 'bind'
};

/**
 * Convert a NodeList into an Array
 * @method nodeListToArray
 * @param NodeList nodeList
 * @return nodeArray
 */
function nodeListToArray(nodeList) {
  var nodeArray = [];
  for (var i = 0; i < nodeList.length; i++) {
    nodeArray.push(nodeList[i]);
  }
  return nodeArray;
}

/**
 * Scope Constructor
 * @method Scope
 * @param Element el
 * @param Object ctx
 * @return Scope instance
 */
function Scope(el, ctx) {
  this.el = el;
  this.ctx = ctx;
}

/**
 * Evaluate
 * @method evaluate
 * @param Object ctx
 * @param string statement
 * @return
 */
function evaluate(ctx, statement) {
  var contextLength = ctx.length;
  var thisCtx = ctx[contextLength - 1];
  var pre = '', post = '';

  for (var i = 0; i < contextLength; i++) {
    pre += 'with (arguments[' + i + '].ctx) {\n';
    post += '\n}';
  }

  return (new Function(pre + ' return ' + statement + ';' + post)).apply(thisCtx, ctx);
}

/**
 * Simple mixin
 * @method mixin
 * @param Object target
 * @param Object source
 * @return target
 */
function mixin(target, source) {
  for (var key in source) {
    target[key] = source[key];
  }
  return target;
}

/**
 * Get the attribute name with any prefix
 * @method getAttrName
 * @param string prefix
 * @param string name
 * @return attributeName
 */
function getAttrName(prefix, name) {
  return prefix ? (prefix + '-' + name) : name;
}

/**
 * Find the Scope of an element
 * @method findScope
 * @param Element el
 * @param [Scopes] scopes
 * @return Scope
 */
function findScope(el, scopes) {

  var scopeElements = scopes.map(function (item) {
    return item.el;
  });

  var idx, check = el;
  while (check) {
    if (check.__ctx) {
      return {
        el: check,
        ctx: check.__ctx
      };
    }

    idx = scopeElements.lastIndexOf(check);
    if (idx !== -1) {
      return scopes[idx];
    }
    check = check.parentNode;
  }

  throw new Error('Unable to resolve scope');
}

/**
 * Find the Scope of an element
 * @method findScope
 * @param Element el
 * @param [Scopes] scopes
 * @return Scope
 */
function findScopes(el, scopes) {

  var scopeChain = [];

  var scopeElements = scopes.map(function (item) {
    return item.el;
  });

  var idx, check = el;

  while (check) {

    if (check.__ctx) {

      return check.__ctx;

    } else {

      idx = scopeElements.lastIndexOf(check);
      if (idx !== -1) {
        scopeChain.unshift(scopes[idx]);
      }

    }

    check = check.parentNode;

  }

  if (!scopeChain.length) {
    throw new Error('Unable to resolve scopes');
  }

  return scopeChain;
}

/**
 * Insert into DOM after the specified element
 * @method insertAfter
 * @param Element newNode
 * @param Element referenceNode
 */
function insertAfter(newNode, referenceNode) {
  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}

/**
 * Superviews
 * @method superviews
 * @param Element rootEl
 * @param Object rootCtx
 * @param Object options
 * @return
 */
function superviews(rootEl, rootCtx, options) {

  rootEl = rootEl || document.body;
  rootCtx = rootCtx || window;

  var opts = Object.create(defaultOptions);

  if (options) {
    mixin(opts, options);
  }

  var prefix = opts.prefix;
  var dupeAttrName = getAttrName(prefix, opts.dupeAttrName);
  var withAttrName = getAttrName(prefix, opts.withAttrName);
  var forAttrName = getAttrName(prefix, opts.forAttrName);
  var ifAttrName = getAttrName(prefix, opts.ifAttrName);
  var attrsAttrName = getAttrName(prefix, opts.attrsAttrName);
  var textAttrName = getAttrName(prefix, opts.textAttrName);
  var htmlAttrName = getAttrName(prefix, opts.valueAttrName);
  var valueAttrName = getAttrName(prefix, opts.valueAttrName);
  var bindAttrName = getAttrName(prefix, opts.bindAttrName);
  var clickAttrName = getAttrName(prefix, 'click');

  var selectors = [withAttrName, forAttrName, textAttrName, ifAttrName,
    attrsAttrName, htmlAttrName, valueAttrName, bindAttrName, clickAttrName
  ];

  // de-duplicate
  Array.prototype.forEach.call(rootEl.querySelectorAll('[' + dupeAttrName + ']'), function (node) {
    node.parentNode.removeChild(node);
  });

  var selector = '[' + selectors.join('],[') + ']';

  scopes = [new Scope(rootEl, rootCtx)];

  function registerIgnoreNode(el) {
    // Push a new Scope object with a special
    // identifier to indicate to child nodes
    // that they need not be processed
    scopes.push(new Scope(el, '__IGNORE__'));
  }
  /**
   * Process an individual element
   * @method processNode
   * @param Element el
   * @return
   */
  function processNode(el) {

    var ctx, attrs, withAttr, forAttr, ifAttr, attrsAttr, textAttr, htmlAttr, valueAttr, bindAttr, clickAttr, forItems;

    attrs = el.attributes;
    ctx = el.__ctx || findScopes(el, scopes);

    // This element could be a child
    // of a node we have already
    // discounted. If so, do no work.
    if (ctx === '__IGNORE__') {
      return;
    }

    withAttr = attrs[withAttrName];
    if (withAttr) {
      var newCtx = evaluate(ctx, withAttr.value);
      scopes.push(new Scope(el, newCtx));
      ctx.push(newCtx);
    }

    ifAttr = attrs[ifAttrName];
    if (ifAttr) {
      var ifTest = !!evaluate(ctx, ifAttr.value);

      if (ifTest) {
        el.style.display = '';
      } else {
        el.style.display = 'none';
        registerIgnoreNode(el);
        return;
      }
    }

    forAttr = attrs[forAttrName];
    if (forAttr) {
      forItems = evaluate(ctx, forAttr.value);

      if (forItems.length) {

        var firstItem = forItems[0];
        var newCtx = new Scope(el, firstItem);

        scopes.push(newCtx);
        ctx.push(newCtx);

        var lastCtxIdx = ctx.length - 1;

        if (forItems.length > 1) {

          var ctnr = document.createElement('div');
          var clone, ctxClone;
          for (var j = 1; j < forItems.length; j++) {
            clone = el.cloneNode(true);
            clone.removeAttribute(forAttrName);
            clone.setAttribute(dupeAttrName, '');
            ctxClone = ctx.slice(0);
            ctxClone[lastCtxIdx] = new Scope(clone, forItems[j]);
            clone.__ctx = ctxClone;
            ctnr.appendChild(clone);
          }
          process(ctnr);

          var after, child;
          while (ctnr.children.length) {
            child = ctnr.children[0];
            insertAfter(child, after || el);
            after = child;
          }

          //ctx[lastCtxIdx] = newCtx;

        }

        el.style.display = '';

      } else {

        // Because the Array is empty we can hide it.
        el.style.display = 'none';

        registerIgnoreNode(el);

        // We can return now as no more processing
        // needs to be done against this node
        return;

      }
    }

    textAttr = attrs[textAttrName];
    if (textAttr) {
      el.innerText = evaluate(ctx, textAttr.value);
    }

    htmlAttr = attrs[htmlAttrName];
    if (htmlAttr) {
      el.innerHTML = evaluate(ctx, htmlAttr.value);
    }

    valueAttr = attrs[valueAttrName];
    if (valueAttr) {
      el.value = evaluate(ctx, valueAttr.value);
    }

    bindAttr = attrs[bindAttrName];
    if (bindAttr) {
      el.value = evaluate(ctx, bindAttr.value);

      if (el.__bind) {
        el.removeEventListener('change', el.__bind);
      }

      el.__bind = function () {
        (new Function('ctx', 'value', 'with (ctx) {\n ' + bindAttr.value + ' = value;\n}'))(ctx, this.value);
      };
      el.addEventListener('change', el.__bind, false);
    }

    attrsAttr = attrs[attrsAttrName];
    if (attrsAttr) {
      var attrsObj = evaluate(ctx, attrsAttr.value);
      for (var attrName in attrsObj) {
        var attrValue = attrsObj[attrName];
        if (attrValue === null || typeof attrValue === 'undefined') {
          el.removeAttribute(attrName);
        } else {
          el.setAttribute(attrName, attrValue);
        }
      }
    }

    clickAttr = attrs[clickAttrName];
    if (clickAttr) {

      if (el.__click && el.__click.ctx !== ctx) {
        el.removeEventListener('click', el.__click.fn);
        delete el.__click;
      }

      if (!el.__click) {
        var fn = function (e) {
          return (new Function('e', 'ctx', 'with (ctx) {\n' + clickAttr.value + '\n}')).call(this, e, ctx);
        };

        el.__click = {
          fn: fn,
          ctx: ctx
        };
        el.addEventListener('click', fn, false);

      }
    }

  }

  /**
   * Processes an element
   * @method process
   * @param Element el
   * @return
   */
  function process(el) {

    var initialSelection = el.querySelectorAll(selector);
    var selection = nodeListToArray(initialSelection);

    // If element has no parent node,
    // assume it's a temporary foreach
    // we are dealing with and don't add
    // it to the list of nodes to process
    if (el.parentNode) {
      selection.unshift(el);
    }

    var node;
    for (var i = 0; i < selection.length; i++) {

      node = selection[i];
      processNode(node);

    }

  }

  process(rootEl);
}

module.exports = superviews;


